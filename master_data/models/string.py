"""
String models for the master_data app.
Handles naming string generation and management.
"""

import uuid
from django.db import models
from django.urls import reverse
from django.core.exceptions import ValidationError
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.utils import timezone

from .base import TimeStampModel, WorkspaceMixin
from ..constants import STRING_VALUE_LENGTH, FREETEXT_LENGTH


class StringQuerySet(models.QuerySet):
    """Custom QuerySet for String model."""

    def for_rule(self, rule):
        """Filter strings for a specific rule."""
        return self.filter(rule=rule)

    def for_field_level(self, level):
        """Filter strings for a specific field level."""
        return self.filter(field__field_level=level)

    def with_conflicts(self):
        """Find strings that have potential naming conflicts."""
        return self.annotate(
            conflict_count=models.Count('rule', 'field', 'value')
        ).filter(conflict_count__gt=1)


class StringManager(models.Manager):
    """Custom manager for String model."""

    def get_queryset(self):
        from .base import get_current_workspace, _thread_locals
        queryset = StringQuerySet(self.model, using=self._db)
        # Auto-filter by workspace if context is set and user is not superuser
        current_workspace = get_current_workspace()
        if current_workspace and not getattr(_thread_locals, 'is_superuser', False):
            queryset = queryset.filter(workspace_id=current_workspace)
        return queryset

    def all_workspaces(self):
        """Get queryset without workspace filtering (for superusers)"""
        return StringQuerySet(self.model, using=self._db)

    def for_workspace(self, workspace_id):
        """Filter queryset by specific workspace"""
        return StringQuerySet(self.model, using=self._db).filter(workspace_id=workspace_id)

    def for_rule(self, rule):
        return self.get_queryset().for_rule(rule)

    def for_field_level(self, level):
        return self.get_queryset().for_field_level(level)


class String(TimeStampModel, WorkspaceMixin):
    """
    Represents a generated naming string based on rule configuration.

    Strings are generated by combining dimension values according to
    platform-specific naming rules and field hierarchies.
    """

    # Relationships
    parent = models.ForeignKey(
        "master_data.String",
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="child_strings",
        help_text="Parent string in hierarchical naming structure"
    )
    field = models.ForeignKey(
        "master_data.Field",
        on_delete=models.CASCADE,
        related_name="field_strings",
        help_text="Field this string belongs to"
    )
    submission = models.ForeignKey(
        "master_data.Submission",
        on_delete=models.CASCADE,
        related_name="submission_strings",
        help_text="Submission that generated this string"
    )
    rule = models.ForeignKey(
        "master_data.Rule",
        on_delete=models.CASCADE,
        related_name="rule_strings",
        editable=False,
        help_text="Rule used to generate this string (auto-set from submission)"
    )

    # Fields
    value = models.CharField(
        max_length=STRING_VALUE_LENGTH,
        help_text="Generated string value following naming convention"
    )
    string_uuid = models.UUIDField(
        default=uuid.uuid4,
        help_text="Unique identifier for this string (unique per workspace)"
    )
    parent_uuid = models.UUIDField(
        null=True,
        blank=True,
        help_text="UUID of parent string for hierarchical linking"
    )
    is_auto_generated = models.BooleanField(
        default=False,
        help_text="Whether this string was automatically generated"
    )
    generation_metadata = models.JSONField(
        default=dict,
        blank=True,
        help_text="Metadata about how this string was generated"
    )
    version = models.IntegerField(
        default=1,
        help_text="Current version number for tracking modifications"
    )

    # Custom manager
    objects = StringManager()

    class Meta:
        verbose_name = "String"
        verbose_name_plural = "Strings"
        # Unique per workspace
        unique_together = [('workspace', 'rule', 'field', 'value')]
        ordering = ['workspace', 'field__field_level', 'value']
        indexes = [
            models.Index(fields=['workspace', 'rule', 'field']),
            models.Index(fields=['workspace', 'string_uuid']),
            models.Index(fields=['workspace', 'value']),
        ]

    def __str__(self):
        return f"Level {self.field.field_level} - {self.field.name}: {self.value}"

    def clean(self):
        """Validate the string configuration."""
        super().clean()

        # Validate value is not empty
        if not self.value or not self.value.strip():
            raise ValidationError("String value cannot be empty")

        # Validate rule belongs to same platform as field
        if self.rule and self.field:
            if self.rule.platform != self.field.platform:
                raise ValidationError(
                    "Rule and field must belong to the same platform")
            if self.workspace and self.rule.workspace != self.workspace:
                raise ValidationError("Rule must belong to the same workspace")

        # Check for naming conflicts within workspace
        conflicts = self.check_naming_conflicts()
        if conflicts:
            raise ValidationError(f"Naming conflict: {conflicts[0]}")

    def save(self, *args, **kwargs):
        """Enhanced save with auto-generation and validation."""
        # Auto-set rule from submission
        if not self.rule_id and self.submission_id:
            self.rule = self.submission.rule

        # Auto-generate UUID if not set (only for new instances without provided UUID)
        if not self.string_uuid:
            self.string_uuid = uuid.uuid4()

        # Full clean to run validation
        self.full_clean()

        super().save(*args, **kwargs)

    def regenerate_value(self, dimension_values=None):
        """
        Regenerate the string value based on current rule configuration.

        Args:
            dimension_values: Optional dict of dimension values to use.
                            If not provided, will use existing StringDetail values.
        """
        from ..services import StringGenerationService

        if not dimension_values:
            dimension_values = self.get_dimension_values()

        if not dimension_values:
            raise ValidationError(
                "No dimension values available for regeneration")

        # Generate new value
        new_value = StringGenerationService.generate_string_value(
            self.rule, self.field, dimension_values
        )

        # Update metadata (convert OrderedDict to dict to preserve order in JSON)
        self.generation_metadata.update({
            'last_regenerated': timezone.now().isoformat(),
            'regenerated_from': self.value,
            'dimension_values_used': dict(dimension_values)
        })

        self.value = new_value
        self.is_auto_generated = True
        self.save()

        return new_value

    def get_dimension_values(self):
        """Get current dimension values as a dictionary ordered by rule configuration."""
        from collections import OrderedDict
        from .rule import RuleDetail
        
        # Get rule details to determine the correct order
        rule_details = RuleDetail.objects.filter(
            rule=self.rule,
            field=self.field
        ).select_related('dimension').order_by('dimension_order')
        
        # Create ordered dictionary following rule order
        values = OrderedDict()
        
        # First pass: add values in rule order
        for rule_detail in rule_details:
            dimension_name = rule_detail.dimension.name
            
            # Find the corresponding string detail
            try:
                string_detail = self.string_details.get(dimension=rule_detail.dimension)
                if string_detail.dimension_value:
                    values[dimension_name] = string_detail.dimension_value.value
                else:
                    values[dimension_name] = string_detail.dimension_value_freetext
            except self.string_details.model.DoesNotExist:
                # If string detail doesn't exist, skip this dimension
                continue
        
        # Second pass: add any remaining dimensions not in rule (shouldn't happen in normal cases)
        for detail in self.string_details.select_related('dimension', 'dimension_value'):
            if detail.dimension.name not in values:
                if detail.dimension_value:
                    values[detail.dimension.name] = detail.dimension_value.value
                else:
                    values[detail.dimension.name] = detail.dimension_value_freetext
        
        return values

    def check_naming_conflicts(self, exclude_self=True):
        """
        Check for potential naming conflicts within the workspace.

        Returns:
            List of conflict descriptions
        """
        conflicts = []

        # Check for duplicate values within same workspace, rule, and field
        duplicate_query = String.objects.filter(
            workspace=self.workspace,
            rule=self.rule,
            field=self.field,
            value=self.value
        )

        if exclude_self and self.pk:
            duplicate_query = duplicate_query.exclude(pk=self.pk)

        if duplicate_query.exists():
            conflicts.append(
                f"Duplicate string value '{self.value}' exists in this workspace")

        return conflicts

    def get_hierarchy_path(self):
        """Get the full hierarchy path for this string."""
        path = []
        current = self

        while current:
            path.insert(0, current)
            current = current.parent

        return path

    def get_child_strings(self):
        """Get all direct child strings."""
        return self.child_strings.all()

    def can_have_children(self):
        """Check if this string can have child strings."""
        next_field = self.field.next_field
        return next_field is not None

    def suggest_child_field(self):
        """Suggest the next field for child string generation."""
        return self.field.next_field

    @classmethod
    def generate_from_submission(cls, submission, field, dimension_values):
        """
        Generate a new string from submission configuration.

        Args:
            submission: Submission instance
            field: Field to generate for
            dimension_values: Dict of dimension values

        Returns:
            New String instance
        """
        from ..services import StringGenerationService

        value = StringGenerationService.generate_string_value(
            submission.rule, field, dimension_values
        )

        return cls.objects.create(
            submission=submission,
            field=field,
            rule=submission.rule,
            workspace=submission.workspace,
            value=value,
            is_auto_generated=True,
            generation_metadata={'dimension_values': dimension_values}
        )

    def get_absolute_url(self):
        return reverse("master_data_String_detail", args=(self.pk,))

    def get_update_url(self):
        return reverse("master_data_String_update", args=(self.pk,))


class StringDetailManager(models.Manager):
    """Custom manager for StringDetail model."""

    def get_queryset(self):
        from .base import get_current_workspace, _thread_locals
        queryset = super().get_queryset()
        # Auto-filter by workspace if context is set and user is not superuser
        current_workspace = get_current_workspace()
        if current_workspace and not getattr(_thread_locals, 'is_superuser', False):
            queryset = queryset.filter(workspace_id=current_workspace)
        return queryset

    def all_workspaces(self):
        """Get queryset without workspace filtering (for superusers)"""
        return super().get_queryset()

    def for_workspace(self, workspace_id):
        """Filter queryset by specific workspace"""
        return super().get_queryset().filter(workspace_id=workspace_id)


class StringDetail(TimeStampModel, WorkspaceMixin):
    """
    Represents dimension values used in string generation.

    Stores the specific dimension values that were combined to create
    the parent string according to the naming rule.
    """

    # Relationships
    string = models.ForeignKey(
        "master_data.String",
        on_delete=models.CASCADE,
        related_name="string_details",
        help_text="String this detail belongs to"
    )
    dimension = models.ForeignKey(
        "master_data.Dimension",
        on_delete=models.CASCADE,
        related_name="string_details",
        help_text="Dimension this value represents"
    )
    dimension_value = models.ForeignKey(
        "master_data.DimensionValue",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="string_details",
        help_text="Predefined dimension value (for list-type dimensions)"
    )

    # Fields
    dimension_value_freetext = models.CharField(
        max_length=FREETEXT_LENGTH,
        null=True,
        blank=True,
        help_text="Free-text dimension value (for text-type dimensions)"
    )

    # Custom manager
    objects = StringDetailManager()

    class Meta:
        verbose_name = "String Detail"
        verbose_name_plural = "String Details"
        # Unique per workspace
        unique_together = [('workspace', 'string', 'dimension')]
        ordering = ['workspace', 'string', 'dimension']

    def clean(self):
        """Validate the string detail configuration."""
        super().clean()

        # Ensure either dimension_value or dimension_value_freetext is provided
        if not self.dimension_value and not self.dimension_value_freetext:
            raise ValidationError(
                "Either dimension value or freetext value must be provided")

        if self.dimension_value and self.dimension_value_freetext:
            raise ValidationError(
                "Cannot specify both dimension value and freetext value")

        # Validate workspace consistency
        if self.string and self.string.workspace != self.workspace:
            raise ValidationError("String must belong to the same workspace")
        if self.dimension and self.dimension.workspace != self.workspace:
            raise ValidationError(
                "Dimension must belong to the same workspace")
        if self.dimension_value and self.dimension_value.workspace != self.workspace:
            raise ValidationError(
                "Dimension value must belong to the same workspace")

    def get_effective_value(self):
        """Get the effective value (either from dimension_value or freetext)."""
        if self.dimension_value:
            return self.dimension_value.value
        return self.dimension_value_freetext

    def __str__(self):
        return f"{self.dimension.name}: {self.get_effective_value()}"

    def get_absolute_url(self):
        return reverse("master_data_StringDetail_detail", args=(self.pk,))

    def get_update_url(self):
        return reverse("master_data_StringDetail_update", args=(self.pk,))


@receiver(post_save, sender=String)
def update_parent_relationship(sender, instance, created, **kwargs):
    """Update parent-child relationships when string is saved."""
    if created and instance.parent_uuid and not instance.parent:
        try:
            parent_string = String.objects.get(
                workspace=instance.workspace,
                string_uuid=instance.parent_uuid
            )
            instance.parent = parent_string
            instance.save(update_fields=['parent'])
        except String.DoesNotExist:
            # Parent might not exist yet in creation workflow
            pass


@receiver(post_save, sender=String)
def log_string_generation(sender, instance, created, **kwargs):
    """Log string generation for audit purposes."""
    if created:
        import logging
        logger = logging.getLogger('master_data.string_generation')
        logger.info(
            f"String generated: {instance.value} "
            f"(Rule: {instance.rule.name}, Field: {instance.field.name}, "
            f"Workspace: {instance.workspace.name})"
        )


# Legacy signal handler - disabled in favor of enhanced version in signals/string_propagation.py
# @receiver(post_save, sender=StringDetail)
def auto_regenerate_string_on_detail_update_legacy(sender, instance, created, **kwargs):
    """
    LEGACY: Automatically regenerate parent string when StringDetail is updated.
    
    This handler has been replaced by the enhanced version in 
    master_data.signals.string_propagation.enhanced_auto_regenerate_string_on_detail_update
    
    Only triggers on updates, not creation.
    """
    pass  # Disabled - using enhanced handler instead


def _propagate_to_child_strings(parent_string, config, logger, current_depth=0):
    """
    Propagate string regeneration to child strings in the hierarchy.
    """
    max_depth = config.get('MAX_INHERITANCE_DEPTH', 5)

    if current_depth >= max_depth:
        logger.warning(
            f"Maximum inheritance depth ({max_depth}) reached for string {parent_string.id}")
        return

    # Get direct child strings
    child_strings = parent_string.child_strings.all()

    if not child_strings.exists():
        return

    logger.info(
        f"Propagating regeneration to {child_strings.count()} child strings of {parent_string.id}")

    for child in child_strings:
        try:
            # Regenerate child string
            old_value = child.value
            child.regenerate_value()

            logger.info(
                f"Child string {child.id} regenerated: '{old_value}' -> '{child.value}' "
                f"(inherited from parent {parent_string.id})"
            )

            # Recursively propagate to grandchildren
            _propagate_to_child_strings(
                child, config, logger, current_depth + 1)

        except Exception as e:
            logger.error(
                f"Failed to regenerate child string {child.id}: {str(e)}")
            # Continue with other children even if one fails
