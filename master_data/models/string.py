"""
String models for the master_data app.
Handles naming string generation and management.
"""

import uuid
from django.db import models
from django.urls import reverse
from django.core.exceptions import ValidationError
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.utils import timezone

from .base import TimeStampModel, WorkspaceMixin
from ..constants import STRING_VALUE_LENGTH, FREETEXT_LENGTH


class StringQuerySet(models.QuerySet):
    """Custom QuerySet for String model."""

    def for_rule(self, rule):
        """Filter strings for a specific rule."""
        return self.filter(rule=rule)

    def for_entity_level(self, level):
        """Filter strings for a specific entity level."""
        return self.filter(entity__entity_level=level)

    def with_conflicts(self):
        """Find strings that have potential naming conflicts."""
        return self.annotate(
            conflict_count=models.Count('rule', 'entity', 'value')
        ).filter(conflict_count__gt=1)


class StringManager(models.Manager):
    """Custom manager for String model."""

    def get_queryset(self):
        from .base import get_current_workspace, _thread_locals
        queryset = StringQuerySet(self.model, using=self._db)
        # Auto-filter by workspace if context is set and user is not superuser
        current_workspace = get_current_workspace()
        if current_workspace and not getattr(_thread_locals, 'is_superuser', False):
            queryset = queryset.filter(workspace_id=current_workspace)
        return queryset

    def all_workspaces(self):
        """Get queryset without workspace filtering (for superusers)"""
        return StringQuerySet(self.model, using=self._db)

    def for_workspace(self, workspace_id):
        """Filter queryset by specific workspace"""
        return StringQuerySet(self.model, using=self._db).filter(workspace_id=workspace_id)

    def for_rule(self, rule):
        return self.get_queryset().for_rule(rule)

    def for_entity_level(self, level):
        return self.get_queryset().for_entity_level(level)


class String(TimeStampModel, WorkspaceMixin):
    """
    Represents a generated naming string based on rule configuration.

    Strings are generated by combining dimension values according to
    platform-specific naming rules and entity hierarchies.
    """

    # Relationships
    parent = models.ForeignKey(
        "master_data.String",
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="child_strings",
        help_text="Parent string in hierarchical naming structure"
    )
    entity = models.ForeignKey(
        "master_data.Entity",
        on_delete=models.CASCADE,
        related_name="entity_strings",
        help_text="Entity this string belongs to"
    )
    submission = models.ForeignKey(
        "master_data.Submission",
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="submission_strings",
        help_text="[DEPRECATED] Submission that generated this string. Use projects instead."
    )
    rule = models.ForeignKey(
        "master_data.Rule",
        on_delete=models.CASCADE,
        related_name="rule_strings",
        editable=False,
        help_text="Rule used to generate this string (auto-set from submission)"
    )

    # Fields
    value = models.CharField(
        max_length=STRING_VALUE_LENGTH,
        help_text="Generated string value following naming convention"
    )
    string_uuid = models.UUIDField(
        default=uuid.uuid4,
        help_text="Unique identifier for this string (unique per workspace)"
    )
    parent_uuid = models.UUIDField(
        null=True,
        blank=True,
        help_text="UUID of parent string for hierarchical linking"
    )
    created_by = models.ForeignKey(
        "users.UserAccount",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="created_strings",
        help_text="User who created this string"
    )
    is_auto_generated = models.BooleanField(
        default=False,
        help_text="Whether this string was automatically generated"
    )
    generation_metadata = models.JSONField(
        default=dict,
        blank=True,
        help_text="Metadata about how this string was generated"
    )
    version = models.IntegerField(
        default=1,
        help_text="Current version number for tracking modifications"
    )

    # External platform integration fields
    validation_source = models.CharField(
        max_length=20,
        choices=[
            ('internal', 'Internal'),
            ('external', 'External'),
        ],
        default='internal',
        help_text="Whether string was generated internally or imported from external platform"
    )
    external_platform_id = models.CharField(
        max_length=100,
        null=True,
        blank=True,
        help_text="Platform-specific identifier (e.g., Meta campaign_123)"
    )
    external_parent_id = models.CharField(
        max_length=100,
        null=True,
        blank=True,
        help_text="Parent's platform identifier for external hierarchy tracking"
    )
    validation_status = models.CharField(
        max_length=20,
        choices=[
            ('valid', 'Valid'),
            ('invalid', 'Invalid'),
            ('warning', 'Warning'),
            ('entity_mismatch', 'Entity Mismatch'),
        ],
        null=True,
        blank=True,
        help_text="Validation status for external strings"
    )
    validation_metadata = models.JSONField(
        default=dict,
        blank=True,
        help_text="Validation errors, warnings, and hierarchy conflicts"
    )

    # Custom manager
    objects = StringManager()

    class Meta:
        verbose_name = "String"
        verbose_name_plural = "Strings"
        # Unique per workspace and parent - allows same value across different parents
        unique_together = [('workspace', 'rule', 'entity', 'parent', 'value')]
        ordering = ['workspace', 'entity__entity_level', 'value']
        indexes = [
            models.Index(fields=['workspace', 'rule', 'entity']),
            models.Index(fields=['workspace', 'string_uuid']),
            models.Index(fields=['workspace', 'value']),
            models.Index(fields=['workspace', 'external_platform_id']),
            models.Index(fields=['validation_source', 'validation_status']),
        ]
        constraints = [
            # Unique external_platform_id per workspace (for external strings)
            models.UniqueConstraint(
                fields=['workspace', 'external_platform_id'],
                condition=models.Q(external_platform_id__isnull=False),
                name='unique_external_platform_id_per_workspace'
            ),
        ]

    def __str__(self):
        return f"Level {self.entity.entity_level} - {self.entity.name}: {self.value}"

    def clean(self):
        """Validate the string configuration."""
        super().clean()

        # Validate value is not empty
        if not self.value or not self.value.strip():
            raise ValidationError("String value cannot be empty")

        # Validate rule belongs to same platform as entity
        if self.rule and self.entity:
            if self.rule.platform != self.entity.platform:
                raise ValidationError(
                    "Rule and entity must belong to the same platform")
            if self.workspace and self.rule.workspace != self.workspace:
                raise ValidationError("Rule must belong to the same workspace")

        # Check for naming conflicts within workspace
        conflicts = self.check_naming_conflicts()
        if conflicts:
            raise ValidationError(f"Naming conflict: {conflicts[0]}")

    def save(self, *args, **kwargs):
        """Enhanced save with auto-generation and validation."""
        # Auto-set rule from submission (legacy support)
        if not self.rule_id and self.submission_id:
            self.rule = self.submission.rule

        # Auto-generate UUID if not set (only for new instances without provided UUID)
        if not self.string_uuid:
            self.string_uuid = uuid.uuid4()

        # Full clean to run validation
        self.full_clean()

        super().save(*args, **kwargs)

    def regenerate_value(self, dimension_values=None):
        """
        Regenerate the string value based on current rule configuration.

        Args:
            dimension_values: Optional dict of dimension values to use.
                            If not provided, will use existing StringDetail values.
        """
        from ..services import StringGenerationService

        if not dimension_values:
            dimension_values = self.get_dimension_values()

        if not dimension_values:
            raise ValidationError(
                "No dimension values available for regeneration")

        # Generate new value
        new_value = StringGenerationService.generate_string_value(
            self.rule, self.entity, dimension_values
        )

        # Update metadata (convert OrderedDict to dict to preserve order in JSON)
        self.generation_metadata.update({
            'last_regenerated': timezone.now().isoformat(),
            'regenerated_from': self.value,
            'dimension_values_used': dict(dimension_values)
        })

        self.value = new_value
        self.is_auto_generated = True
        self.save()

        return new_value

    def get_dimension_values(self):
        """Get current dimension values as a dictionary ordered by rule configuration."""
        from collections import OrderedDict
        from .rule import RuleDetail
        
        # Get rule details to determine the correct order
        rule_details = RuleDetail.objects.filter(
            rule=self.rule,
            entity=self.entity
        ).select_related('dimension').order_by('dimension_order')
        
        # Create ordered dictionary following rule order
        values = OrderedDict()
        
        # First pass: add values in rule order
        for rule_detail in rule_details:
            dimension_name = rule_detail.dimension.name
            
            # Find the corresponding string detail
            try:
                string_detail = self.string_details.get(dimension=rule_detail.dimension)
                if string_detail.dimension_value:
                    values[dimension_name] = string_detail.dimension_value.value
                else:
                    values[dimension_name] = string_detail.dimension_value_freetext
            except self.string_details.model.DoesNotExist:
                # If string detail doesn't exist, skip this dimension
                continue
        
        # Second pass: add any remaining dimensions not in rule (shouldn't happen in normal cases)
        for detail in self.string_details.select_related('dimension', 'dimension_value'):
            if detail.dimension.name not in values:
                if detail.dimension_value:
                    values[detail.dimension.name] = detail.dimension_value.value
                else:
                    values[detail.dimension.name] = detail.dimension_value_freetext
        
        return values

    def check_naming_conflicts(self, exclude_self=True):
        """
        Check for potential naming conflicts within the workspace.

        Returns:
            List of conflict descriptions
        """
        conflicts = []

        # Check for duplicate values within same workspace, rule, and entity
        duplicate_query = String.objects.filter(
            workspace=self.workspace,
            rule=self.rule,
            entity=self.entity,
            value=self.value
        )

        if exclude_self and self.pk:
            duplicate_query = duplicate_query.exclude(pk=self.pk)

        if duplicate_query.exists():
            conflicts.append(
                f"Duplicate string value '{self.value}' exists in this workspace")

        return conflicts

    def get_hierarchy_path(self):
        """Get the full hierarchy path for this string."""
        path = []
        current = self

        while current:
            path.insert(0, current)
            current = current.parent

        return path

    def get_child_strings(self):
        """Get all direct child strings."""
        return self.child_strings.all()

    def can_have_children(self):
        """Check if this string can have child strings."""
        next_entity = self.entity.next_entity
        return next_entity is not None

    def suggest_child_entity(self):
        """Suggest the next entity for child string generation."""
        return self.entity.next_entity

    @classmethod
    def generate_from_submission(cls, submission, entity, dimension_values):
        """
        Generate a new string from submission configuration.

        Args:
            submission: Submission instance
            entity: Entity to generate for
            dimension_values: Dict of dimension values

        Returns:
            New String instance
        """
        from ..services import StringGenerationService

        value = StringGenerationService.generate_string_value(
            submission.rule, entity, dimension_values
        )

        return cls.objects.create(
            submission=submission,
            entity=entity,
            rule=submission.rule,
            workspace=submission.workspace,
            value=value,
            is_auto_generated=True,
            generation_metadata={'dimension_values': dimension_values}
        )

    def get_absolute_url(self):
        return reverse("master_data_String_detail", args=(self.pk,))

    def get_update_url(self):
        return reverse("master_data_String_update", args=(self.pk,))


class StringDetailManager(models.Manager):
    """Custom manager for StringDetail model."""

    def get_queryset(self):
        from .base import get_current_workspace, _thread_locals
        queryset = super().get_queryset()
        # Auto-filter by workspace if context is set and user is not superuser
        current_workspace = get_current_workspace()
        if current_workspace and not getattr(_thread_locals, 'is_superuser', False):
            queryset = queryset.filter(workspace_id=current_workspace)
        return queryset

    def all_workspaces(self):
        """Get queryset without workspace filtering (for superusers)"""
        return super().get_queryset()

    def for_workspace(self, workspace_id):
        """Filter queryset by specific workspace"""
        return super().get_queryset().filter(workspace_id=workspace_id)


class StringDetail(TimeStampModel, WorkspaceMixin):
    """
    Represents dimension values used in string generation.

    Stores the specific dimension values that were combined to create
    the parent string according to the naming rule.
    """

    # Relationships
    string = models.ForeignKey(
        "master_data.String",
        on_delete=models.CASCADE,
        related_name="string_details",
        help_text="String this detail belongs to"
    )
    dimension = models.ForeignKey(
        "master_data.Dimension",
        on_delete=models.CASCADE,
        related_name="string_details",
        help_text="Dimension this value represents"
    )
    dimension_value = models.ForeignKey(
        "master_data.DimensionValue",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="string_details",
        help_text="Predefined dimension value (for list-type dimensions)"
    )

    # Fields
    dimension_value_freetext = models.CharField(
        max_length=FREETEXT_LENGTH,
        null=True,
        blank=True,
        help_text="Free-text dimension value (for text-type dimensions)"
    )

    # Custom manager
    objects = StringDetailManager()

    class Meta:
        verbose_name = "String Detail"
        verbose_name_plural = "String Details"
        # Unique per workspace
        unique_together = [('workspace', 'string', 'dimension')]
        ordering = ['workspace', 'string', 'dimension']

    def clean(self):
        """Validate the string detail configuration."""
        super().clean()

        # Ensure either dimension_value or dimension_value_freetext is provided
        if not self.dimension_value and not self.dimension_value_freetext:
            raise ValidationError(
                "Either dimension value or freetext value must be provided")

        if self.dimension_value and self.dimension_value_freetext:
            raise ValidationError(
                "Cannot specify both dimension value and freetext value")

        # Validate workspace consistency
        if self.string and self.string.workspace != self.workspace:
            raise ValidationError("String must belong to the same workspace")
        if self.dimension and self.dimension.workspace != self.workspace:
            raise ValidationError(
                "Dimension must belong to the same workspace")
        if self.dimension_value and self.dimension_value.workspace != self.workspace:
            raise ValidationError(
                "Dimension value must belong to the same workspace")

    def get_effective_value(self):
        """Get the effective value (either from dimension_value or freetext)."""
        if self.dimension_value:
            return self.dimension_value.value
        return self.dimension_value_freetext

    def __str__(self):
        return f"{self.dimension.name}: {self.get_effective_value()}"

    def get_absolute_url(self):
        return reverse("master_data_StringDetail_detail", args=(self.pk,))

    def get_update_url(self):
        return reverse("master_data_StringDetail_update", args=(self.pk,))


@receiver(post_save, sender=String)
def update_parent_relationship(sender, instance, created, **kwargs):
    """Update parent-child relationships when string is saved."""
    # Avoid infinite recursion by checking if we're already in an update
    if hasattr(instance, '_updating_parent_relationship'):
        return
    
    needs_update = False
    update_fields = []
    
    # Set parent from parent_uuid if parent is missing
    if created and instance.parent_uuid and not instance.parent:
        try:
            parent_string = String.objects.get(
                workspace=instance.workspace,
                string_uuid=instance.parent_uuid
            )
            instance.parent = parent_string
            needs_update = True
            update_fields.append('parent')
        except String.DoesNotExist:
            # Parent might not exist yet in creation workflow
            pass
    
    # Set parent_uuid from parent if parent_uuid is missing or mismatched
    if instance.parent and (not instance.parent_uuid or instance.parent_uuid != instance.parent.string_uuid):
        instance.parent_uuid = instance.parent.string_uuid
        needs_update = True
        update_fields.append('parent_uuid')
    
    # Clear parent_uuid if parent is None
    if not instance.parent and instance.parent_uuid:
        instance.parent_uuid = None
        needs_update = True
        update_fields.append('parent_uuid')
    
    if needs_update:
        # Mark instance to avoid recursion
        instance._updating_parent_relationship = True
        try:
            instance.save(update_fields=update_fields)
        finally:
            # Clean up the flag
            delattr(instance, '_updating_parent_relationship')


@receiver(post_save, sender=String)
def log_string_generation(sender, instance, created, **kwargs):
    """Log string generation for audit purposes."""
    if created:
        import logging
        logger = logging.getLogger('master_data.string_generation')
        logger.info(
            f"String generated: {instance.value} "
            f"(Rule: {instance.rule.name}, Entity: {instance.entity.name}, "
            f"Workspace: {instance.workspace.name})"
        )


def _propagate_to_child_strings(parent_string, config, logger, current_depth=0):
    """
    Propagate string regeneration to child strings in the hierarchy.
    """
    max_depth = config.get('MAX_INHERITANCE_DEPTH', 5)

    if current_depth >= max_depth:
        logger.warning(
            f"Maximum inheritance depth ({max_depth}) reached for string {parent_string.id}")
        return

    # Get direct child strings
    child_strings = parent_string.child_strings.all()

    if not child_strings.exists():
        return

    logger.info(
        f"Propagating regeneration to {child_strings.count()} child strings of {parent_string.id}")

    for child in child_strings:
        try:
            # Regenerate child string
            old_value = child.value
            child.regenerate_value()

            logger.info(
                f"Child string {child.id} regenerated: '{old_value}' -> '{child.value}' "
                f"(inherited from parent {parent_string.id})"
            )

            # Recursively propagate to grandchildren
            _propagate_to_child_strings(
                child, config, logger, current_depth + 1)

        except Exception as e:
            logger.error(
                f"Failed to regenerate child string {child.id}: {str(e)}")
            # Continue with other children even if one fails
