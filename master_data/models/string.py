"""
String models for the master_data app.
Handles naming string generation and management.
"""

import uuid
from django.db import models
from django.urls import reverse
from django.core.exceptions import ValidationError
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.utils import timezone

from .base import TimeStampModel
from ..constants import STRING_VALUE_LENGTH, FREETEXT_LENGTH


class StringQuerySet(models.QuerySet):
    """Custom QuerySet for String model."""

    def for_rule(self, rule):
        """Filter strings for a specific rule."""
        return self.filter(rule=rule)

    def for_field_level(self, level):
        """Filter strings for a specific field level."""
        return self.filter(field__field_level=level)

    def with_conflicts(self):
        """Find strings that have potential naming conflicts."""
        return self.annotate(
            conflict_count=models.Count('rule', 'field', 'value')
        ).filter(conflict_count__gt=1)


class StringManager(models.Manager):
    """Custom manager for String model."""

    def get_queryset(self):
        return StringQuerySet(self.model, using=self._db)

    def for_rule(self, rule):
        return self.get_queryset().for_rule(rule)

    def for_field_level(self, level):
        return self.get_queryset().for_field_level(level)


class String(TimeStampModel):
    """
    Represents a generated naming string based on rule configuration.

    Strings are generated by combining dimension values according to
    platform-specific naming rules and field hierarchies.
    """

    # Relationships
    parent = models.ForeignKey(
        "master_data.String",
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="child_strings",
        help_text="Parent string in hierarchical naming structure"
    )
    field = models.ForeignKey(
        "master_data.Field",
        on_delete=models.CASCADE,
        related_name="field_strings",
        help_text="Field this string belongs to"
    )
    submission = models.ForeignKey(
        "master_data.Submission",
        on_delete=models.CASCADE,
        related_name="submission_strings",
        help_text="Submission that generated this string"
    )
    rule = models.ForeignKey(
        "master_data.Rule",
        on_delete=models.CASCADE,
        related_name="rule_strings",
        editable=False,
        help_text="Rule used to generate this string (auto-set from submission)"
    )

    # Fields
    value = models.CharField(
        max_length=STRING_VALUE_LENGTH,
        help_text="Generated string value following naming convention"
    )
    string_uuid = models.UUIDField(
        unique=True,
        default=uuid.uuid4,
        help_text="Unique identifier for this string"
    )
    parent_uuid = models.UUIDField(
        null=True,
        blank=True,
        help_text="UUID of parent string for hierarchical linking"
    )
    is_auto_generated = models.BooleanField(
        default=False,
        help_text="Whether this string was automatically generated"
    )
    generation_metadata = models.JSONField(
        default=dict,
        blank=True,
        help_text="Metadata about how this string was generated"
    )

    # Custom manager
    objects = StringManager()

    class Meta:
        verbose_name = "String"
        verbose_name_plural = "Strings"
        unique_together = ('rule', 'field', 'value')
        ordering = ['field__field_level', 'value']
        indexes = [
            models.Index(fields=['rule', 'field']),
            models.Index(fields=['string_uuid']),
            models.Index(fields=['value']),
        ]

    def __str__(self):
        return f"Level {self.field.field_level} - {self.field.name}: {self.value}"

    def clean(self):
        """Validate the string configuration."""
        super().clean()

        # Validate value is not empty
        if not self.value or not self.value.strip():
            raise ValidationError("String value cannot be empty")

        # Validate rule belongs to same platform as field
        if self.rule and self.field and self.rule.platform != self.field.platform:
            raise ValidationError(
                "Rule and field must belong to the same platform")

        # Check for naming conflicts
        conflicts = self.check_naming_conflicts()
        if conflicts:
            raise ValidationError(f"Naming conflict: {conflicts[0]}")

    def save(self, *args, **kwargs):
        """Enhanced save with auto-generation and validation."""
        # Auto-set rule from submission
        if not self.rule_id and self.submission_id:
            self.rule = self.submission.rule

        # Auto-generate UUID if not set (only for new instances without provided UUID)
        if not self.string_uuid:
            self.string_uuid = uuid.uuid4()

        # Full clean to run validation
        self.full_clean()

        super().save(*args, **kwargs)

    def regenerate_value(self, dimension_values=None):
        """
        Regenerate the string value based on current rule configuration.

        Args:
            dimension_values: Optional dict of dimension values to use.
                            If not provided, will use existing StringDetail values.
        """
        from ..services import StringGenerationService

        if not dimension_values:
            dimension_values = self.get_dimension_values()

        if not dimension_values:
            raise ValidationError(
                "No dimension values available for regeneration")

        # Generate new value
        new_value = StringGenerationService.generate_string_value(
            self.rule, self.field, dimension_values
        )

        # Update metadata
        self.generation_metadata.update({
            'last_regenerated': timezone.now().isoformat(),
            'regenerated_from': self.value,
            'dimension_values_used': dimension_values
        })

        self.value = new_value
        self.is_auto_generated = True
        self.save()

        return new_value

    def get_dimension_values(self):
        """Get current dimension values as a dictionary."""
        values = {}

        for detail in self.string_details.select_related('dimension', 'dimension_value'):
            dimension_name = detail.dimension.name

            if detail.dimension_value:
                values[dimension_name] = detail.dimension_value.value
            elif detail.dimension_value_freetext:
                values[dimension_name] = detail.dimension_value_freetext

        return values

    def check_naming_conflicts(self, exclude_self=True):
        """Check for naming conflicts with other strings."""
        from ..services import StringGenerationService

        exclude_id = self.id if exclude_self else None
        return StringGenerationService.check_naming_conflicts(
            self.rule, self.field, self.value, exclude_id
        )

    def get_hierarchy_path(self):
        """Get the full hierarchy path for this string."""
        path = [self]
        current = self.parent

        while current:
            path.insert(0, current)
            current = current.parent

        return path

    def get_child_strings(self):
        """Get all child strings in the hierarchy."""
        return String.objects.filter(parent=self).order_by('field__field_level')

    def can_have_children(self):
        """Check if this string can have child strings."""
        # Check if there are fields at higher levels
        next_field = self.field.child_fields.first()
        return next_field is not None

    def suggest_child_field(self):
        """Suggest the next field for creating child strings."""
        return self.field.child_fields.first()

    @classmethod
    def generate_from_submission(cls, submission, field, dimension_values):
        """
        Class method to generate a new string from a submission.

        This is the recommended way to create new strings with auto-generation.
        """
        from ..services import StringGenerationService

        return StringGenerationService.create_string_with_details(
            submission, field, dimension_values
        )

    def get_absolute_url(self):
        return reverse("master_data_String_detail", args=(self.pk,))

    def get_update_url(self):
        return reverse("master_data_String_update", args=(self.pk,))


class StringDetail(TimeStampModel):
    """
    Represents dimension values used in string generation.

    Stores the specific dimension values that were combined to create
    the parent string according to the naming rule.
    """

    # Relationships
    string = models.ForeignKey(
        "master_data.String",
        on_delete=models.CASCADE,
        related_name="string_details",
        help_text="String this detail belongs to"
    )
    dimension = models.ForeignKey(
        "master_data.Dimension",
        on_delete=models.CASCADE,
        related_name="string_details",
        help_text="Dimension this value represents"
    )
    dimension_value = models.ForeignKey(
        "master_data.DimensionValue",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="string_details",
        help_text="Predefined dimension value (for list-type dimensions)"
    )

    # Fields
    dimension_value_freetext = models.CharField(
        max_length=FREETEXT_LENGTH,
        null=True,
        blank=True,
        help_text="Free text value (for text-type dimensions)"
    )

    class Meta:
        verbose_name = "String Detail"
        verbose_name_plural = "String Details"
        unique_together = ('string', 'dimension')
        ordering = ['string', 'dimension']

    def clean(self):
        """Validate string detail configuration."""
        super().clean()

        # Ensure either dimension_value or dimension_value_freetext is provided
        if not self.dimension_value and not self.dimension_value_freetext:
            raise ValidationError(
                "Either dimension_value or dimension_value_freetext must be provided")

        # Validate dimension type consistency
        if self.dimension.type == 'list' and not self.dimension_value:
            raise ValidationError(
                "List-type dimensions must use dimension_value, not freetext")

        if self.dimension.type == 'text' and self.dimension_value:
            raise ValidationError(
                "Text-type dimensions should use dimension_value_freetext")

    def get_effective_value(self):
        """Get the effective value (either from dimension_value or freetext)."""
        if self.dimension_value:
            return self.dimension_value.value
        return self.dimension_value_freetext

    def __str__(self):
        effective_value = self.get_effective_value()
        return f"{self.string.field.name} - {self.dimension.name}: {effective_value}"

    def get_absolute_url(self):
        return reverse("master_data_StringDetail_detail", args=(self.pk,))

    def get_update_url(self):
        return reverse("master_data_StringDetail_update", args=(self.pk,))


@receiver(post_save, sender=String)
def update_parent_relationship(sender, instance, created, **kwargs):
    """Signal handler to update parent relationships based on parent_uuid."""
    if created and instance.parent_uuid and not instance.parent:
        try:
            parent_string = String.objects.get(
                string_uuid=instance.parent_uuid)
            instance.parent = parent_string
            # Avoid recursion by using update
            String.objects.filter(pk=instance.pk).update(parent=parent_string)
        except String.DoesNotExist:
            pass  # Parent not found - this is acceptable


@receiver(post_save, sender=String)
def log_string_generation(sender, instance, created, **kwargs):
    """Signal handler to log string generation events."""
    if created and instance.is_auto_generated:
        # Update generation metadata
        metadata = instance.generation_metadata.copy()
        metadata.update({
            'generated_at': timezone.now().isoformat(),
            'rule_used': instance.rule.name,
            'field_level': instance.field.field_level,
            'platform': instance.rule.platform.name
        })

        # Use update to avoid recursion
        String.objects.filter(pk=instance.pk).update(
            generation_metadata=metadata
        )
